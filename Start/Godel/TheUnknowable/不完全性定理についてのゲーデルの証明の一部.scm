; Gödel's_proof_of_his incompleteness_theorem
; http://www.unfindable.net/article/unknowable/godel.html
; これは「証明」というよりも「ゲーデルの定理の主張」を説明するための文書である
(load "Lib/lib.scm")

; うそつきのパラドックス： 「この文はうそである」

; ゲーデルの定理： 「この命題は証明できない」（真なのに証明できない命題がある）

(newline)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(display "準備運動") (newline)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 自分のコードを出力するプログラムの例

; quines
(define f (lambda (x) `(,x ',x)))
(f 'x)                        ; => (x 'x)
(f 'f)                        ; => (f 'f)
(eval (f 'f))                 ; => (f 'f)
(equal? (f 'f) (eval (f 'f))) ; => #t

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(display "ゲーデルの定理") (newline)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 「文に数を対応させるが、文の中で数を扱うことができるためにレベルが縮退する」というのがゲーデルの方法の本質である。 
; 「表現に名前を対応させるが、表現の中で名前を扱うことができるためにレベルが縮退する」というのが以下の方法の本質である。 
; （これが簡単に実現できるのは、ここで扱う言語では表現が first-class だからである。 First-class については SICP を参照）
; 表現に名前を対応させるのは簡単で、 Mathematica ならば Hold を、 Scheme や Lisp ならば quote を使えばよい。

; x が妥当な証明でないなら False を返し、妥当な証明なら証明された定理を返すような関数 valid-proof? があるとする（これは難しくないはず）。
; すべての x について 
; valid-proof? x 
; が y と等しくないとき、 y は証明不可能である。
; このことを主張する述語を is-unprovable とする

; 名前 x に対して、表現 
; (is-unprovable (value-of (x 'x))) 
; を返すような関数 g を考える
(define g (lambda (x) `(is-unprovable (value-of (,x ',x)))))
g      ; => (λ(x) -> `(is-unprovable (value-of (,x ',x))))
(g 'x) ; => (is-unprovable (value-of (x 'x)))

; g に自分自身を作用させた結果は、
(g 'g) ; => (is-unprovable (value-of (g 'g)))
; となり、 (g 'g) が証明不可能だと主張している。
; つまり、 (g 'g) は 「この式は証明できない」 を意味する式である。

; (g 'g) は証明可能であろうか。
; 証明可能だという結論は (g 'g) の主張と矛盾する。
; よって (g 'g) は証明可能ではない。
; しかしこれは (g 'g) の主張である。よって、 (g 'g) は証明不可能だが真である

(cadr (cadr (g 'g))) 
; => (g 'g)
(eval (cadr (cadr (g 'g)))) 
; => (is-unprovable (value-of (g 'g)))

(newline)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(display "準備運動 - original version") (newline)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; 自分のコードを出力するプログラムの例

; quines
(set! f (lambda (x) `(',x ',x)))
(f 'x)
(f f)
(eval (f f))
(equal? (f f) (eval (f f)))

; => ('x 'x)
; => ('(λ(x) -> `(',x ',x)) '(λ(x) -> `(',x ',x)))
; => ('(λ(x) -> `(',x ',x)) '(λ(x) -> `(',x ',x)))
; => #t

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(display "ゲーデルの定理 - original version") (newline)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! g (lambda (x) `(is-unprovable (value-of (',x ',x))))) ; => g
g      ; => (λ(x) -> `(is-unprovable (value-of (',x ',x))))
(g 'x) ; => (is-unprovable (value-of ('x 'x)))

(g g)  
; => (is-unprovable (value-of ('(λ(x) -> `(is-unprovable (value-of (',x ',x)))) '(λ(x) -> `(is-unprovable (value-of (',x ',x)))))))

(cadr (cadr (g g)))        
; => ('(λ(x) -> `(is-unprovable (value-of (',x ',x)))) '(λ(x) -> `(is-unprovable (value-of (',x ',x)))))
(eval (cadr (cadr (g g)))) 
; => (is-unprovable (value-of ('(λ(x) -> `(is-unprovable (value-of (',x ',x)))) '(λ(x) -> `(is-unprovable (value-of (',x ',x)))))))

(equal? (g g) (eval (cadr (cadr (g g)))))
; => #t



